IP层解析：
			0      4        8            16     19      24           31
			—————————————————————————————+——————————————————————————-
			| 版本 |首部长度|  区分服务  |        总长度            |
			+————————————————————————————+——————+————————————————————
			|            标识            | 标志 |      偏移量       |
			+———————————————————————————————————+————————————————————
			|   生存时间    |    协议    |       首部检验和         |
			+————————————————————————————————————————————————————————
			|                        源地址                         |
			+————————————————————————————————————————————————————————
			|                       目的地址                        |
			+———————————————————————————————————————————+————————————
			|   可选字段(长度可变)                      |   填充    |
			---------------------------------------------------------
	[1:0-3]：标识ip协议版本；0x4:标识ipv4
	[1:4-7]：ip首部长度，单位32bit(4字节)。如，0x5就表示首部长度为5*4=20字节
		   4bit 可以表示最大的数为 0xF，因此，IP 头部的最大长度为 15*4=60B
	[1:8-15]：服务类型TOS
		   该段数据组成为 3bit 优先权字段(现已被忽略) + 4bit TOS 字段 + 1bit 保留字段(须为0)。
		   4bit TOS 字段分别表示自小时延、最大吞吐量、最高可用性和最小费用。只能置其中 1bit，全为 0 表示一般服务。现在大多数的TCP/IP实现都不支持TOS特性 。可以看到，本报文 TOS 字段为全 0。
	[1:16-31]：IP报文总长度
		   单位字节，从占位数来算， IP 数据报最长为 2^16=65535B。但大部分网络的链路层 MTU（最大传输单元）没有这么大，一些上层协议或主机也不会接受这么大的，故超长 IP 数据报在传输时会被分片。
	[2:0-15]：标识
		   唯一的标识主机发送的每一个数据报。通常每发送一个报文，它的值+1。当 IP 报文分片时，该标识字段值被复制到所有数据分片的标识字段中，使得这些分片在达到最终目的地时可以依照标识字段的内容重新组成原先的数据。
	[2:16-31]:3bit标志 + 13bit片偏移
		   3bit 标志对应 R、DF、MF。目前只有后两位有效。
				DF位：为1表示不分片，为0表示分片。
				MF：为1表示“更多的片”，为0表示这是最后一片。
		   13bit 片位移：本分片在原先数据报文中相对首位的偏移位。（需要再乘以8）
	[3:0-7]：生存时间TTL
		   IP 报文所允许通过的路由器的最大数量。每经过一个路由器，TTL减1，当为 0 时，路由器将该数据报丢弃。TTL 字段是由发送端初始设置一个 8 bit字段.推荐的初始值由分配数字 RFC 指定。发送 ICMP 回显应答时经常把 TTL 设为最大值 255。TTL可以防止数据报陷入路由循环。
	[3:8-15]：协议
		   指出 IP 报文携带的数据使用的是哪种协议，以便目的主机的IP层能知道要将数据报上交到哪个进程。
		   TCP 的协议号为6，UDP 的协议号为17。ICMP 的协议号为1，IGMP 的协议号为2
	[3:16-31]：IP首部校验和
		   由发送端填充。以本报文为例，先说这个值是怎么计算出来的。
			1、 将校验和字段 16bit 值抹去变为 `0x0000`，然后将首部 20字节值相加
			0x4560 + 0x0042 + 0x7567 + 0x0000 + 0x3d06 + 0x0000 + 0xC0A8 + 0x011A + 0xC0A8 +0x0116 = 0x27B95

			2、 将上述结果的进位 2 与低 16bit 相加【即把0x27B95中高位的2拿掉，然后和剩下的相加】
			0x7B95 + 0x2 = 0x7B97

			3、 0x7B97 按位取反
			~(0x7B97) = 0x8468
			结果 0x8468 即为该字段值！
			接收端验证的时候，进行以下计算

			# 20B 首部值相加
			0x27B95 + 0x8468 = 0x2FFFD

			# 将上述结果的进位 2 与低 16bit 相加
			0xFFFD + 0x2 = 0xFFFF

			# 0xFFFF 按位取反
			~(0xFFFF) = 0  <-- 正确
	
传输层解析：
			0                                   16     19      24           31
			————————————————————————————————————+——————————————————————————-
			|       16bit源端口                 |       16bit目的端口      |
			+———————————————————————————————————+——————+————————————————————
			|                             32bit序列号                      |
			+———————————————————————————————————+———————————————————————————
			|                             32bit确认号                      |
			+———————————————————————————————————+———————————————————————————
			|4bit首部长度|6bit保留位|U|A|P|R|S|F|        16bit窗口大小     |
			+———————————————————————————————————+———————————————————————————
			|         16bit校验和               |      16bit紧急指针       |
			+———————————————————————————————————————————————————————————————
			|                         可选项(长度可变)                     |
			----------------------------------------------------------------
	注： TCP 的头部必须是 4字节的倍数,而大多数选项不是4字节倍数,不足的用 NOP 填充。
		【1】16bit，源端口
			 16bit 决定了端口号的最大值为 65535.
		【2】16bit，目的端口
		【3】32bit，序号
		【4】32bit，确认号
		【5】4bit，TCP 报文首部长度
			 也叫 offset，其实也就是数据从哪里开始。同 IP 头部类似，最大长度为 60B。
		【6】6bit, 保留位
			 保留为今后使用，但目前应置为 0。
		【7】6bit，TCP 标志位
			    从左到右依次是：
			    URG：紧急
			    ACK：确认
			    PSH：推送
			    RST：复位
			    SYN：同步
			    FIN：终止
		【8】16bit，滑动窗口大小
		【9】16bit，校验和
		由发送端填充，接收端对 TCP 报文段执行 CRC 算法，以检验 TCP 报文段在传输过程中是否损坏，如果损坏这丢弃。
		检验范围包括首部和数据两部分，这也是 TCP 可靠传输的一个重要保障。
		【10】16bit，紧急指针
			  仅在 URG = 1 时才有意义，它指出本报文段中的紧急数据的字节数。
			  当 URG = 1 时，发送方 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。
		【11】tcp可选项，格式如下：
				Kind/Type(1B)  |  Len(1B)   |  Value


进制转换：
	十六进制转十进制：
		1、echo $((0xf))  or  echo $((0xF))
		2、echo "ibase=16; F"  | bc
		3、((num=16#A))
		   echo $num
		
	十进制转十六进制：
		echo "ibase=10;obase=16;15" | bc
	 or echo "obase=16;15" | bc
	 
	 十进制转二进制：
		echo "ibase=2;10" | bc
	
	十六进制转二进制：[反过来就不行]
		echo "ibase=16;obase=2;A" | bc
		
消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。

原理：
AMQP: (Advanced Message Queuing Protocol,高级信息队列协议)是应用层协议的一个开放标准，为面向消息的中间件设计。
AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。
AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。

RabbitMQ是一个开源的AMQP实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。

解决的问题：
RabbitMQ就是当前最主流的消息中间件之一
    两个（多个）系统间需要通过定时任务来同步某些数据
    异构系统的不同进程间相互调用、通讯的问题

Queue：(队列)
	是RabbitMQ的内部对象，用于存储消息。
	生产者  生产消息  发送  到RabbitMQ中  存储在Queue中；
	消费者  消费消息  从RabbitMQ的Queue中  获取
	多个消费者  平均分摊消息。（每个消费者获取1/n条消息）

术语：
	broker：消息队列服务器实体，RabbitMQ部署服务器，即快递公司
	producer：消息生产者，即寄件人
	consumer：消息消费者，即取件人
	vhost：虚拟主机，即菜鸟驿站的储物柜
		注：一个broker里可以开设多个vhost，用作权限分离，把不同的系统使用的rabbitmq区分开，共用一个消息队列服务器，但看上去就像各自在用不用的rabbitmq服务器一样。
	Connection：一个网络连接，比如TCP/IP套接字连接
	channel：消息通道
		是建立在真实的TCP连接内的虚拟连接（是我们与RabbitMQ打交道的最重要的一个接口）。仅仅创建了客户端到Broker之间的连接后，客户端还是不能发送消息的,需要为每一个Connection创建Channel，AMQP协议规定只有通过Channel才能执行AMQP的命令。AMQP的命令都是通过信道发送出去的（我们大部分的业务操作是在Channel这个接口中完成的，包括定义Queue、定义Exchange、绑定Queue与Exchange、发布消息等。）。每条信道都会被指派一个唯一ID。在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务,理论上无限制，减少TCP创建和销毁的开销，实现共用TCP的效果。之所以需要Channel，是因为TCP连接的建立和释放都是十分昂贵的，如果一个客户端每一个线程都需要与Broker交互，如果每一个线程都建立一个TCP连接，暂且不考虑TCP连接是否浪费，就算操作系统也无法承受每秒建立如此多的TCP连接。注1：一个生产者或一个消费者与MQ服务器之间只有一条TCP连接 注2：RabbitMQ建议客户端线程之间不要共用Channel，至少要保证共用Channel的线程发送消息必须是串行的，但是建议尽量共用Connection。
	Exchange：消息交换机，生产者不是直接将消息投递到Queue中的，实际上是生产者将消息发送到Exchange（交换器），由Exchange将消息路由到一个或多个Queue中（或者丢弃）。
	Exchange Types RabbitMQ常用的Exchange Type有fanout、direct、topic、headers这四种（AMQP规范里还提到两种Exchange Type，分别为system与自定义，）
	Queue：消息队列载体，每个消息都会被投入到一个或多个队列。
	Binding：绑定，它的作用就是把exchange和queue按照路由规则绑定起来，这样RabbitMQ就知道如何正确地将消息路由到指定的Queue了。
	Routing Key：路由关键字，生产者在将消息发送给Exchange的时候，一般会指定一个routing key，来指定这个消息的路由规则，而这个routing key需要与Exchange Type及binding key联合使用才能最终生效。
	Prefetch count: 多个消费者同时订阅同一个Queue中的消息，Queue中的消息会被平摊给多个消费者。这时如果每个消息的处理时间不同，就有可能会导致某些消费者一直在忙，而另外一些消费者很快就处理完手头工作并一直空闲的情况。我们可以通过设置prefetchCount来限制Queue每次发送给每个消费者的消息数，比如我们设置prefetchCount=1，则Queue每次给每个消费者发送一条消息；消费者处理完这条消息后Queue会再给该消费者发送一条消息。

消息队列使用过程：
	在AMQP中，EXCHANGE是接受producer消息的关键组件。ExchangeType和Binding决定了消息的路由规则。所以生产者想要发送消息，首先必须要声明一个Exchange和该Exchange对应的Binding。
	在RabbitMQ中要声明一个Exchange需要三个参数：ExchangeName、ExchangeType和Durable。Durable是该Exchange的持久化属性。
	声明一个Binding需要提供一个QueueName，ExchangeName和BindingKey。



<center>
<font color=blue size=10>
Redie笔记
</font>
</center>

# <!-- TOC --> 目录

- [](#) 
- [redis的优缺点：](#redis的优缺点)
- [为什么要用 Redis /为什么要用缓存？](#为什么要用-redis-为什么要用缓存)
- [为什么用redis缓存，不用本地缓存？](#为什么用redis缓存不用本地缓存)
- [redis为什么这么快](#redis为什么这么快)
- [redis有哪些数据类型？](#redis有哪些数据类型)
- [redis的应用场景有哪些？](#redis的应用场景有哪些)
- [为什么redis要数据持久化？](#为什么redis要数据持久化)
- [Redis 的持久化机制是什么？各自的优缺点？](#redis-的持久化机制是什么各自的优缺点)
- [redis的过期键的删除策略？](#redis的过期键的删除策略)
- [MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？](#mysql里有2000w数据redis中只存20w的数据如何保证redis中的数据都是热点数据)
- [Redis的内存淘汰策略有哪些？](#redis的内存淘汰策略有哪些)
- [Redis的内存用完了会发生什么？](#redis的内存用完了会发生什么)
- [Redis线程模型](#redis线程模型)
- [什么是事务？](#什么是事务)
- [redis集群](#redis集群)
	- [redis哨兵](#redis哨兵)
	- [官方redis cluster方案（服务路由查询）](#官方redis-cluster方案服务路由查询)
	- [为什么要做Redis分区？](#为什么要做redis分区)
	- [Redis有那些分区实现方案？](#redis有那些分区实现方案)
	- [redis分区有什么缺点？](#redis分区有什么缺点)
	- [redis实现分布式锁](#redis实现分布式锁)
	- [如何解决 Redis 的并发竞争 Key 问题](#如何解决-redis-的并发竞争-key-问题)
	- [缓存雪崩](#缓存雪崩)
	- [缓存穿透](#缓存穿透)
	- [缓存击穿](#缓存击穿)
	- [缓存预热](#缓存预热)
	- [redis和Memcached的区别：](#redis和memcached的区别)
- [一个字符串类型的值能存储最大容量是多少？](#一个字符串类型的值能存储最大容量是多少)
	- [两个问题](#两个问题)
	- [使用Redis做过异步队列吗，是如何实现的？](#使用redis做过异步队列吗是如何实现的)
	- [Redis如何实现延时队列？](#redis如何实现延时队列)
	- [Redis回收进程如何工作的？](#redis回收进程如何工作的)
	- [Redis回收使用的是什么算法？](#redis回收使用的是什么算法)

<!-- /TOC -->

# redis的优缺点：
  优点：
	读写性能优异， Redis能读的速度是110000次/s，写的速度是81000次/s。
	支持数据持久化，支持AOF和RDB两种持久化方式。
	支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。
	数据结构丰富，除了支持string类型的value外还支持hash、set、zset、list等数据结构。
	支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。

  缺点：
	数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。
	Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。
	主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。
	Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。

# 为什么要用 Redis /为什么要用缓存？
  主要从“高性能”和“高并发”这两点来看待这个问题
	高性能：
	  操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！
	高并发：
	  直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。

# 为什么用redis缓存，不用本地缓存？
  缓存分为本地缓存和分布式缓存。以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，  \  
   并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。
  使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 redis 或 memcached服务的高可用，  \
   整个程序架构上较为复杂。

# redis为什么这么快
  1）完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是O(1)；
  2）数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的；
  3）采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；
  4）使用多路 I/O 复用模型，非阻塞 IO；
  5）使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；

# redis有哪些数据类型？
  redis有5中数据类型：string、list、set、zset、hash

# redis的应用场景有哪些？
  总结一：
	计数器：可以对 String 进行自增自减运算，从而实现计数器功能。Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。
	缓存：将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。
	会话缓存：可以使用 Redis 来统一存储多台应用服务器的会话信息。当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。
	全页缓存（FPC）：除基本的会话token之外，Redis还提供很简便的FPC平台。以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。此外， \
					对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。
	查找表：例如 DNS 记录就很适合使用 Redis 进行存储。查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。
	消息队列(发布/订阅功能)：List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息。不过最好使用 Kafka、RabbitMQ 等消息中间件。
	分布式锁实现：在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。
	其它：Set 可以实现交集、并集等操作，从而实现共同好友等功能。ZSet 可以实现有序性操作，从而实现排行榜等功能。

  总结二：
	Redis相比其他缓存，有一个非常大的优势，就是支持多种数据类型。 数据类型说明string字符串，最简单的k-v存储hashhash格式，value为field和value，  \ 
	 适合ID-Detail这样的场景。list简单的list，顺序列表，支持首位或者末尾插入数据set无序list，查找速度快，适合交集、并集、差集处理sorted set有序的set
	其实，通过上面的数据类型的特性，基本就能想到合适的应用场景了。
	
	  string——适合最简单的k-v存储，类似于memcached的存储结构，短信验证码，配置信息等，就用这种类型来存储。
	  hash——一般key为ID或者唯一标示，value对应的就是详情了。如商品详情，个人信息详情，新闻详情等。
	  list——因为list是有序的，比较适合存储一些有序且数据相对固定的数据。如省市区表、字典表等。因为list是有序的，适合根据写入的时间来排序，如：最新的***，消息队列等。
	  set——可以简单的理解为ID-List的模式，如微博中一个人有哪些好友，set最牛的地方在于，可以对两个set提供交集、并集、差集操作。例如：查找两个人共同的好友等。
	  Sorted Set——是set的增强版本，增加了一个score参数，自动会根据score的值进行排序。比较适合类似于top 10等不根据插入的时间来排序的数据。
	如上所述，虽然Redis不像关系数据库那么复杂的数据结构，但是，也能适合很多场景，比一般的缓存数据结构要多。了解每种数据结构适合的业务场景，不仅有利于提升开发效率，也能有效利用Redis的性能。

# 为什么redis要数据持久化？
  持久化就是把内存的数据写到磁盘中去，防止服务宕机后内存数据丢失
  
# Redis 的持久化机制是什么？各自的优缺点？
  Redis 提供两种持久化机制 RDB（默认） 和 AOF 机制:
	RDB：是Redis DataBase缩写快照【适合对数据完整性和一致性要求不高的场景使用】
	  RDB是按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为dump.rdb。通过配置文件中的save参数来定义快照的周期。
		优点：
		  1、只有一个文件 dump.rdb，方便持久化。
		  2、容灾性好，一个文件可以保存到安全的磁盘。
		  3、性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能
		  4.相对于数据集大时，比 AOF 的启动效率更高。
		 缺点：
		  1、数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候)
		  2、由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。
		  
	AOF：(即Append Only File持久化)，则是将Redis执行的每次写命令记录到单独的日志文件中，当重启Redis会重新将持久化的日志中文件恢复数据。
	  优点：
		1、数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次 命令操作就记录到 aof 文件中一次。
		2、通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。
		3、AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）)
	  缺点：
		1、AOF 文件比 RDB 文件大，且恢复速度慢。
		2、数据集大的时候，比 rdb 启动效率低。
		
	RDB和AOF的区别是什么？
	  AOF文件比RDB更新频率高，优先使用AOF还原数据。
	  AOF比RDB更安全也更大
	  RDB性能比AOF好
	  如果两个都配了优先加载AOF

# redis的过期键的删除策略？
  过期策略通常有以下三种：
	a、定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好； \
				但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。
	b、惰性过期：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极 \
				端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。
	c、定期过期：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折 \
				中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。
	  (expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳 \
	  表示的过期时间。键空间是指该Redis集群中保存的所有键。)
  Redis中同时使用了惰性过期和定期过期两种过期策略。

# MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？
  redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。

# Redis的内存淘汰策略有哪些？
  Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。
  全局的键空间选择性移除:
	noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。
	allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。（这个是最常用的）
	allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。

  设置过期时间的键空间选择性移除
	volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。
	volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。
	volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。

  注释：Redis的内存淘汰策略的选取并不会影响过期的key的处理。内存淘汰策略用于处理内存不足时的需要申请额外空间的数据；过期策略用于处理过期的缓存数据。

# Redis的内存用完了会发生什么？
  如果达到设置的上限，Redis的写命令会返回错误信息（但是读命令还可以正常返回。）或者你可以配置内存淘汰机制，当Redis达到内存上限时会冲刷掉旧的内容。

# Redis线程模型
  Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为文件事件处理器（file event handler）。它的组成结构为4部分：多个套接字、IO多路复用程序、文件事件分派器、事件处理器。因为  \
  文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型。
	文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。
	当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调  \
	 用套接字之前关联好的事件处理器来处理这些事件。

  虽然文件事件处理器以单线程方式运行， 但通过使用 I/O 多路复用程序来监听多个套接字， 文件事件处理器既实现了高性能的网络通信模型， 又可以很好地与 redis 服务器  \
   中其他同样以单线程方式运行的模块进行对接， 这保持了 Redis 内部单线程设计的简单性。

# 什么是事务？
  事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。
  事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。
  
  Redis事务的概念
	Redis 事务的本质是通过MULTI、EXEC、WATCH等一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。 \
	 在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。
  总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。

  redis事务的三个阶段：
	事务开始  MULTI
	命令入队
	事务执行EXEC
  事务执行过程中，如果服务端收到有EXEC、DISCARD、WATCH、MULTI之外的请求，将会把请求放入队列中排队

  Redis事务相关命令
	Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的。
	  1）redis 不支持回滚，“Redis 在事务失败时不进行回滚，而是继续执行余下的命令”， 所以 Redis 的内部可以保持简单且快速。
	  2）如果在一个事务中的命令出现错误，那么所有的命令都不会执行；
	  3）如果在一个事务中出现运行错误，那么正确的命令会被执行。
	  
	WATCH 命令是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。
	MULTI命令用于开启一个事务，它总是返回OK。MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中， \
	 当EXEC命令被调用时，所有队列中的命令才会被执行。
	EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。当操作被打断时，返回空值 nil 。
	DISCARD的作用：在客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。
	UNWATCH命令可以取消watch对所有key的监控。

  事务管理（ACID）概述：
	原子性（Atomicity）：原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。
	一致性（Consistency）：事务前后数据的完整性必须保持一致。
	隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。
	持久性（Durability）：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响
  Redis的事务总是具有ACID中的一致性和隔离性，其他特性是不支持的。当服务器运行在AOF持久化模式下，并且appendfsync选项的值为always时，事务也具有持久性。
  
 
# redis集群
## redis哨兵
  sentinel是redis集群中的非常重要的一个组件
  主要功能：
	集群监控：监控master和slave是否正常工作
	消息通知：如果某redis实例故障，sentinel负责发送消息作为报警通知管理员
	故障转移：如果master宕机，会自动转移到某slaveNode上
	配置中心：如果发生故障转移，通知client客户端新的master地址
  
  特点：
	哨兵至少3个实例，来保证自己的健壮性
	哨兵 + redis主从 的架构，只能保证redis集群的高可用，不能保证数据零丢失
	
## 官方redis cluster方案（服务路由查询）
  Redis cluster是一种服务的sharding技术，没有使用一致性hash而是采用slot（槽）的概念，一共分成16384个槽，将请求发送到任意节点，接收到请求的节点将会  \
   查询请求发送到正确的节点上执行
  方案说明：
	通过哈希的方式，将数据分片，每个节点均分存储一定哈希槽(哈希值)区间的数据，默认分配了16384 个槽位
	每份数据分片会存储在多个互为主从的多节点上
	数据写入先写主节点，再同步到从节点(支持配置为阻塞同步)
	同一分片多个节点间的数据不保持一致性
	读取数据时，当客户端操作的key没有分配在该节点上时，redis会返回转向指令，指向正确的节点
	扩容时时需要需要把旧节点的数据迁移一部分到新节点
  
  redis cluster架构中，每个redis要开发2个端口，一个是6379，另一个就是加1W的端口好，如果16379
	16379端口号是用来进行节点间通信的，作用：进行故障检测、配置更新、故障转移授权。
  集群节点之间使用gossip协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间。
  分布式寻址算法：
	hash 算法（大量缓存重建）
	一致性 hash 算法（自动缓存迁移）+ 虚拟节点（自动负载均衡）
	redis cluster 的 hash slot 算法

	优点：
	  无中心架构，支持动态扩容，对业务透明
	  具备Sentinel的监控和自动Failover(故障转移)能力
	  客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可
	  高性能，客户端直连redis服务，免去了proxy代理的损耗
	缺点：
	  运维也很复杂，数据迁移需要人工干预
	  只能使用0号数据库
	  不支持批量操作(pipeline管道操作)
	  分布式逻辑和存储模块耦合等

## 为什么要做Redis分区？
  分区可以让Redis管理更大的内存，Redis将可以使用所有机器的内存。如果没有分区，你最多只能使用一台机器的内存。分区使Redis的计算  \
   能力通过简单地增加计算机得到成倍提升，Redis的网络带宽也会随着计算机和网卡的增加而成倍增长。

## Redis有那些分区实现方案？
  a、客户端分区：就是在客户端就已经决定数据会被存储到哪个redis节点或者从哪个redis节点读取。大多数客户端已经实现了客户端分区
  b、代理分区：客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。redis和memcached的一种代理实现就是 Twemproxy
  c、查询路由：是客户端随机地请求任意一个redis实例，然后由Redis将请求转发给正确的Redis节点。Redis Cluster实现了一种混合形式的  \
	  查询路由，但并不是直接将请求从一个redis节点转发到另一个redis节点，而是在客户端的帮助下直接redirected到正确的redis节点。
  
## redis分区有什么缺点？
  涉及多个key的操作通常不会被支持。例如你不能对两个集合求交集，因为他们可能被存储到不同的Redis实例
  同时操作多个key,则不能使用Redis事务.
  分区使用的粒度是key，不能使用一个非常长的排序key存储一个数据集
  当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不同的Redis实例和主机同时收集RDB / AOF文件。
  分区时动态扩容或缩容可能非常复杂。Redis集群在运行时增加或者删除Redis节点，能做到最大程度对用户透明地数据再平衡，但  \
   其他一些客户端分区或者代理分区方法则不支持这种特性。然而，有一种预分片的技术也可以较好的解决这个问题。

## redis实现分布式锁
  Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争关系Redis中可以使用SETNX命令实现分布式锁。
  
  当且仅当 key 不存在，将 key 的值设为 value。若给定的 key 已经存在，则 SETNX 不做任何动作。
  SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。
  返回值：设置成功，返回 1 。设置失败，返回 0 。
	> setnx lock-key  value1
	<integer> 1
	> setnx lock-key  value2
	<integer> 0
	> get lock-key
	"value1"
  使用SETNX完成同步锁的流程及事项如下：
	使用SETNX命令获取锁，若返回0（key已存在，锁已存在）则获取失败，反之获取成功。
	为了防止获取锁后程序出现异常，导致其他线程/进程调用SETNX命令总是返回0而进入死锁状态，需要为该key设置一个“合理”的过期时间。
	释放锁，使用DEL命令将锁数据删除。

## 如何解决 Redis 的并发竞争 Key 问题
  所谓 Redis 的并发竞争 Key 的问题也就是多个系统同时对一个 key 进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同！
  
  推荐一种方案：分布式锁（zookeeper 和 redis 都可以实现分布式锁）。（如果不存在 Redis 的并发竞争 Key 问题，不要使用分布式锁，这样会影响性能）
  
  基于zookeeper临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下， \
   生成一个唯一的瞬时有序节点。判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。当释放锁的时候，只需将这个瞬时节点删除即可。同时，\
   可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。
  在实践中，当然是从以可靠性为主。所以首推Zookeeper。

## 缓存雪崩
  缓存雪崩是指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。
  解决方案：
	缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。
	一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。
	给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存。

## 缓存穿透
  缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。
  
## 缓存击穿
  缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时  \
   去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。
  解决方案:
	设置热点数据永远不过期。
	加互斥锁，互斥锁

## 缓存预热
  缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！
  解决方案：
	直接写个缓存刷新页面，上线时手工操作一下；
	数据量不大，可以在项目启动的时候自动进行加载；
	定时刷新缓存；

## redis和Memcached的区别：
  两者都是非关系型内存键值数据库，现在公司一般都是用 Redis 来实现缓存，而且 Redis 自身也越来越强大了！
  Redis 与 Memcached 主要有以下不同：
	类型：
	  redis支持内存，非关系型数据库
	  memcached支持内存，键值对形式，缓存形式
	数据缓存类型：
	  redis： string、list、set、hash、sortset（即Zset）
	  memcached： 文本型、二进制类型
	查询操作：
	  redis：批量操作、事务支持、每个类型不同的CRUD
	  memcached：常用的CRUD、少量的其他命令
	附件功能：
	  redis：发布/订阅模式、主从分区、序列化支持、脚本支持（lua脚本）
	  memcached：多线程服务支持
	网络IO模型：
	  redis：单线程的多路IO复用模型
	  memcached：多线程，非阻塞IO模式
	集群模式：
	  redis：原生支持cluster模式、主从模式
	  memcached：没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据
	内存管理：
	  redis：并不是全部数据在内存中，有一部分很久没用的数据交换到磁盘
	  memcached：数据会一直在内存中，把内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题，但会使内存的利用率不高
	使用场景：
	  redis：复杂数据结构，有持久化，高可用需求，value存储内容较大
	  memcached：纯key-value，数据量非常大，并发非常大的业务
	持久化：
	  redis：支持，RDB和AOF两种方式
	  memcached：不支持
	
	(1) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型
	(2) redis的速度比memcached快很多
	(3) redis可以持久化其数据

# 一个字符串类型的值能存储最大容量是多少？
  512M

## 两个问题
 a、假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？
	使用keys指令可以扫出指定模式的key列表。  

  b、对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？   
	这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。  \
	这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。

## 使用Redis做过异步队列吗，是如何实现的？
  使用list类型保存数据信息，rpush生产消息，lpop消费消息，当lpop没有消息时，可以sleep一段时间，然后再检查有没有信息，如果不想sleep的话，  \
  可以使用blpop, 在没有信息的时候，会一直阻塞，直到信息的到来。redis可以通过pub/sub主题订阅模式实现一个生产者，多个消费者，当然也存在一定的缺点，当消费者下线时，生产的消息会丢失。

## Redis如何实现延时队列？
  使用sortedset，使用时间戳做score, 消息内容作为key,调用zadd来生产消息，消费者使用zrangbyscore获取n秒之前的数据做轮询处理。

## Redis回收进程如何工作的？
  一个客户端运行了新的命令，添加了新的数据。
  Redis检查内存使用情况，如果大于maxmemory的限制， 则根据设定好的策略进行回收。
  一个新的命令被执行，等等。
  所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。
  
  如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。

## Redis回收使用的是什么算法？

LRU算法:[最近最久未使用算法]

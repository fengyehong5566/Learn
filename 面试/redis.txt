@redis的优缺点：
  优点：
    读写性能优异， Redis能读的速度是110000次/s，写的速度是81000次/s。
    支持数据持久化，支持AOF和RDB两种持久化方式。
    支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。
    数据结构丰富，除了支持string类型的value外还支持hash、set、zset、list等数据结构。
    支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。

  缺点：
    数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。
    Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。
    主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。
    Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。

@为什么要用 Redis /为什么要用缓存？
  主要从“高性能”和“高并发”这两点来看待这个问题
    高性能：
      操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！
    高并发：
      直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。

@为什么用redis缓存，不用本地缓存？
  缓存分为本地缓存和分布式缓存。以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，  \  
   并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。
  使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 redis 或 memcached服务的高可用，  \
   整个程序架构上较为复杂。

@redis为什么这么快
  1）完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是O(1)；
  2）数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的；
  3）采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；
  4）使用多路 I/O 复用模型，非阻塞 IO；
  5）使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；

@redis有哪些数据类型？
  redis有5中数据类型：string、list、set、zset、hash

@redis的应用场景有哪些？
  总结一：
    计数器：可以对 String 进行自增自减运算，从而实现计数器功能。Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。
    缓存：将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。
    会话缓存：可以使用 Redis 来统一存储多台应用服务器的会话信息。当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。
    全页缓存（FPC）：除基本的会话token之外，Redis还提供很简便的FPC平台。以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。此外， \
                    对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。
    查找表：例如 DNS 记录就很适合使用 Redis 进行存储。查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。
    消息队列(发布/订阅功能)：List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息。不过最好使用 Kafka、RabbitMQ 等消息中间件。
    分布式锁实现：在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。
    其它：Set 可以实现交集、并集等操作，从而实现共同好友等功能。ZSet 可以实现有序性操作，从而实现排行榜等功能。

  总结二：
    Redis相比其他缓存，有一个非常大的优势，就是支持多种数据类型。 数据类型说明string字符串，最简单的k-v存储hashhash格式，value为field和value，  \ 
     适合ID-Detail这样的场景。list简单的list，顺序列表，支持首位或者末尾插入数据set无序list，查找速度快，适合交集、并集、差集处理sorted set有序的set
    其实，通过上面的数据类型的特性，基本就能想到合适的应用场景了。
    
      string——适合最简单的k-v存储，类似于memcached的存储结构，短信验证码，配置信息等，就用这种类型来存储。
      hash——一般key为ID或者唯一标示，value对应的就是详情了。如商品详情，个人信息详情，新闻详情等。
      list——因为list是有序的，比较适合存储一些有序且数据相对固定的数据。如省市区表、字典表等。因为list是有序的，适合根据写入的时间来排序，如：最新的***，消息队列等。
      set——可以简单的理解为ID-List的模式，如微博中一个人有哪些好友，set最牛的地方在于，可以对两个set提供交集、并集、差集操作。例如：查找两个人共同的好友等。
      Sorted Set——是set的增强版本，增加了一个score参数，自动会根据score的值进行排序。比较适合类似于top 10等不根据插入的时间来排序的数据。
    如上所述，虽然Redis不像关系数据库那么复杂的数据结构，但是，也能适合很多场景，比一般的缓存数据结构要多。了解每种数据结构适合的业务场景，不仅有利于提升开发效率，也能有效利用Redis的性能。

@为什么redis要数据持久化？
  持久化就是把内存的数据写到磁盘中去，防止服务宕机后内存数据丢失
  
@Redis 的持久化机制是什么？各自的优缺点？
  Redis 提供两种持久化机制 RDB（默认） 和 AOF 机制:
    RDB：是Redis DataBase缩写快照【适合对数据完整性和一致性要求不高的场景使用】
      RDB是按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为dump.rdb。通过配置文件中的save参数来定义快照的周期。
        优点：
          1、只有一个文件 dump.rdb，方便持久化。
          2、容灾性好，一个文件可以保存到安全的磁盘。
          3、性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能
          4.相对于数据集大时，比 AOF 的启动效率更高。
         缺点：
          1、数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候)
          2、由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。
          
    AOF：(即Append Only File持久化)，则是将Redis执行的每次写命令记录到单独的日志文件中，当重启Redis会重新将持久化的日志中文件恢复数据。
      优点：
        1、数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次 命令操作就记录到 aof 文件中一次。
        2、通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。
        3、AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）)
      缺点：
        1、AOF 文件比 RDB 文件大，且恢复速度慢。
        2、数据集大的时候，比 rdb 启动效率低。
        
    RDB和AOF的区别是什么？
      AOF文件比RDB更新频率高，优先使用AOF还原数据。
      AOF比RDB更安全也更大
      RDB性能比AOF好
      如果两个都配了优先加载AOF

@redis的过期键的删除策略？
  过期策略通常有以下三种：
    a、定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好； \
                但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。
    b、惰性过期：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极 \
                端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。
    c、定期过期：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折 \
                中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。
      (expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳 \
      表示的过期时间。键空间是指该Redis集群中保存的所有键。)
  Redis中同时使用了惰性过期和定期过期两种过期策略。

@MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？
  redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。

@Redis的内存淘汰策略有哪些？
  Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。
  全局的键空间选择性移除:
    noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。
    allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。（这个是最常用的）
    allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。

  设置过期时间的键空间选择性移除
    volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。
    volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。
    volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。

  注释：Redis的内存淘汰策略的选取并不会影响过期的key的处理。内存淘汰策略用于处理内存不足时的需要申请额外空间的数据；过期策略用于处理过期的缓存数据。

@Redis的内存用完了会发生什么？
  如果达到设置的上限，Redis的写命令会返回错误信息（但是读命令还可以正常返回。）或者你可以配置内存淘汰机制，当Redis达到内存上限时会冲刷掉旧的内容。

@Redis线程模型
  Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为文件事件处理器（file event handler）。它的组成结构为4部分：多个套接字、IO多路复用程序、文件事件分派器、事件处理器。因为  \
  文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型。
    文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。
    当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调  \
     用套接字之前关联好的事件处理器来处理这些事件。

  虽然文件事件处理器以单线程方式运行， 但通过使用 I/O 多路复用程序来监听多个套接字， 文件事件处理器既实现了高性能的网络通信模型， 又可以很好地与 redis 服务器  \
   中其他同样以单线程方式运行的模块进行对接， 这保持了 Redis 内部单线程设计的简单性。

@什么是事务？
  事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。
  事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。
  
  Redis事务的概念
    Redis 事务的本质是通过MULTI、EXEC、WATCH等一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。 \
     在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。
  总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。

  redis事务的三个阶段：
    事务开始  MULTI
    命令入队
    事务执行EXEC
  事务执行过程中，如果服务端收到有EXEC、DISCARD、WATCH、MULTI之外的请求，将会把请求放入队列中排队

  Redis事务相关命令
    Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的。
      1）redis 不支持回滚，“Redis 在事务失败时不进行回滚，而是继续执行余下的命令”， 所以 Redis 的内部可以保持简单且快速。
      2）如果在一个事务中的命令出现错误，那么所有的命令都不会执行；
      3）如果在一个事务中出现运行错误，那么正确的命令会被执行。
      
    WATCH 命令是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。
    MULTI命令用于开启一个事务，它总是返回OK。MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中， \
     当EXEC命令被调用时，所有队列中的命令才会被执行。
    EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。当操作被打断时，返回空值 nil 。
    DISCARD的作用：在客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。
    UNWATCH命令可以取消watch对所有key的监控。

  事务管理（ACID）概述：
    原子性（Atomicity）：原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。
    一致性（Consistency）：事务前后数据的完整性必须保持一致。
    隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。
    持久性（Durability）：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响
  Redis的事务总是具有ACID中的一致性和隔离性，其他特性是不支持的。当服务器运行在AOF持久化模式下，并且appendfsync选项的值为always时，事务也具有持久性。
  
 
@@redis集群
@redis哨兵
  sentinel是redis集群中的非常重要的一个组件
  主要功能：
    集群监控：监控master和slave是否正常工作
    消息通知：如果某redis实例故障，sentinel负责发送消息作为报警通知管理员
    故障转移：如果master宕机，会自动转移到某slaveNode上
    配置中心：如果发生故障转移，通知client客户端新的master地址
  
  特点：
    哨兵至少3个实例，来保证自己的健壮性
    哨兵 + redis主从 的架构，只能保证redis集群的高可用，不能保证数据零丢失
    
@官方redis cluster方案（服务路由查询）
  Redis cluster是一种服务的sharding技术，没有使用一致性hash而是采用











